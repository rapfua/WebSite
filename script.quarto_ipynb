{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"INDY Notes & Simulations\"\n",
        "format: dashboard\n",
        "server: shiny\n",
        "editor:\n",
        "  markdown:\n",
        "    wrap: 72\n",
        "---"
      ],
      "id": "112b943a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "# format: dashboard\n",
        "# server: shiny\n",
        "# editor: \n",
        "#   markdown: \n",
        "#     wrap: 72\n",
        "\n",
        "# ---\n",
        "# title: \"INDY Notes & Simulations\"\n",
        "# format: html\n",
        "# execute:\n",
        "#   eval: false\n",
        "# ---"
      ],
      "id": "8dc5a601",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "############################################################################################################ \n",
        "\n",
        "# § Percolation Demo\n"
      ],
      "id": "0799fc6e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "context": "setup"
      },
      "source": [
        "#| echo: false\n",
        "\n",
        "\n",
        "import shiny\n",
        "import random\n",
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "from matplotlib.lines import Line2D\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "from numpy.random import poisson, uniform\n",
        "\n",
        "import scipy.sparse\n",
        "\n",
        "from sklearn.cluster import SpectralClustering\n",
        "from sklearn.metrics import adjusted_rand_score\n",
        "\n",
        "\n",
        "from shiny.express import render, ui"
      ],
      "id": "c893e05d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: graph_builder.py\n",
        "\n",
        "import graphlearning as gl\n",
        "\n",
        "def get_Gaussian_weight_matrix(X, k):\n",
        "    Z = gl.weightmatrix.knn(X, k)  # Gaussian similarity measure\n",
        "    A = (Z + Z.T) / 2\n",
        "    return A"
      ],
      "id": "graph_builderpy",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: metric_backbone.py\n",
        "\n",
        "import networkx as nx\n",
        "import igraph as ig\n",
        "\n",
        "def get_metric_backbone_igraph(D):\n",
        "    \"\"\"\n",
        "     :param D: networkx distance graph (with weight and proximity edge attribute)\n",
        "     :return: Networkx Metric Backbone subgraph of D\n",
        "    \"\"\"\n",
        "    D_ig = ig.Graph.from_networkx(D)\n",
        "    #print(D_ig.distances(weights='weight'))\n",
        "    distances = D_ig.distances(weights='weight')\n",
        "\n",
        "    B = nx.Graph(D)\n",
        "    B.remove_edges_from([(x, y) for x, y, w in B.edges.data('weight') if w > distances[x][y]])\n",
        "    return B"
      ],
      "id": "metric_backbonepy",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: global-variables\n",
        "\n",
        "global_SEED = 42"
      ],
      "id": "global-variables",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##  {.sidebar width=\"300px\"}\n"
      ],
      "id": "b4565bff"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ui.input_select(\"p\", \"Probability:\",\n",
        "                choices=[x / 100 for x in range(1, 100)],\n",
        "                selected=0.5,\n",
        "                width=10\n",
        ")\n",
        "ui.input_select(\"grid_size\", \"Number of nodes in each dimension:\",\n",
        "                choices=[x for x in range(2, 101)],\n",
        "                selected=10\n",
        ")"
      ],
      "id": "ce04dcbf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Column\n"
      ],
      "id": "1e3ed46b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "@render.plot\n",
        "def displot():\n",
        "    p = float(input.p())\n",
        "    grid_size = int(input.grid_size())\n",
        "    G = nx.grid_2d_graph(grid_size, grid_size)\n",
        "    pos = {(x, y): (x, y) for x, y in G.nodes()}\n",
        "    \n",
        "    plt.figure(figsize=(6, 6))\n",
        "    \n",
        "    for (u, v) in G.edges():\n",
        "        edge_color = 'red' if random.random() < p else 'black'\n",
        "        edge_width = 3 if edge_color == 'red' else 1  # Thicker for red edges\n",
        "        nx.draw_networkx_edges(G, pos, edgelist=[(u, v)], edge_color=edge_color, width=edge_width)\n",
        "    \n",
        "    nx.draw_networkx_nodes(G, pos, node_size=0)\n",
        "    \n",
        "    legend_elements = [\n",
        "        Line2D([0], [0], color='red', lw=3, label  ='open   & w(e) = 1'),\n",
        "        Line2D([0], [0], color='black', lw=1, label='closed & w(e) = 0'),\n",
        "    ]\n",
        "    \n",
        "    plt.legend(handles=legend_elements, bbox_to_anchor=(1.4, 0.96))\n",
        "    plt.gca().set_aspect('equal')\n",
        "    plt.axis('off')\n",
        "    plt.title(f\"{grid_size}x{grid_size} Grid with p = {p:.2f}\", fontsize=14)\n",
        "    plt.text(0.5, -0.05, 'Figure 1: each edge is open with probability p.',\n",
        "         fontsize=12, ha='center', va='center', transform=plt.gca().transAxes)\n",
        "\n",
        "    # Adjust layout to ensure the caption fits within the figure area\n",
        "    plt.tight_layout()"
      ],
      "id": "258b7b20",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "############################################################################################################ \n",
        "\n",
        "# § Introduction\n",
        "\n",
        "<h2>Bernoulli Bond Percolation on $\\mathbb{Z}^d$</h2>\n",
        "\n",
        "<h3>Setup:</h3>\n",
        "\n",
        "-   $G = (\\mathbb{Z}^d, E)$\n",
        "-   $E = \\{(x, y) \\in \\mathbb{Z}^d \\times \\mathbb{Z}^d : ||x - y||_1 = 1\\}$\n",
        "\n",
        "<h3>Probabilistic framework $(\\Omega, \\mathcal{F}, \\mathbb{P_p})$</h3>\n",
        "\n",
        "-   $\\Omega = \\{0, 1\\}^E$\n",
        "-   $\\mathcal{F}=$ product $\\sigma$-algebra\n",
        "-   $\\mathbb{P}_p = \\text{Bernoulli}(p)^{\\bigotimes E}$\n",
        "\n",
        "<h3>Properties:</h3>\n",
        "\n",
        "-   Let $\\omega, \\eta \\in \\{0, 1\\}^E$ be two configurations. We define\n",
        "    the following **ordering**: <br>\n",
        "\n",
        "$\\qquad \\qquad \\omega \\leq \\eta \\quad \\iff \\quad \\omega(e) \\leq \\eta(e) \\quad \\forall e \\in E.$\n",
        "<br>\n",
        "\n",
        "-   An **event** $A \\in \\mathcal{F}$ is **increasing** if\n",
        "\n",
        "    $\\qquad \\omega \\in A \\quad \\& \\quad \\omega \\leq \\eta \\implies \\eta \\in A.$\n",
        "    <br>\n",
        "\n",
        "    -   Examples:\n",
        "        $\\{x \\xleftrightarrow{} y\\} \\text{ } \\& \\text{ } \\{|C_x| \\geq 10\\}$\n",
        "        are increasing events.\n",
        "\n",
        "    -   Remark : $A, B$ increasing\n",
        "        $\\implies A \\cap B \\text{ } \\& \\text{ } A \\cup B$ increasing.\n",
        "\n",
        "    -   Nonexample: $\\{|C_0| = 10\\}$ is not increasing. <br> <br>\n",
        "\n",
        "-   A **function** $f: \\Omega \\to \\mathbb{R}$ is **increasing** if\n",
        "\n",
        "    $\\qquad \\omega \\leq \\eta \\implies f(\\omega) \\leq f(\\eta).$ <br>\n",
        "\n",
        "    -   Example: $f(\\omega) = |C_0(\\omega)|$ is an increasing function.\n",
        "\n",
        "    -   Connection: event $A$ increasing $\\iff$ function $\\mathbb{1}_A$\n",
        "        increasing. <br> <br>\n",
        "\n",
        "-   Les $(\\Omega, \\mathcal{A}, P)$ be a probability space. <br> A map\n",
        "    $X: \\Omega \\to \\mathbb{R}$ is a **random variable** if\n",
        "    $X^{-1}(B) \\stackrel{\\text{notation}}{=} \\{X \\in B\\} \\in \\mathcal{A}$\n",
        "    for all Borel sets $B \\in \\mathcal{B}(\\mathbb{R})$. <br> In other\n",
        "    words: $X$ must a measurable map from $(\\Omega, \\mathcal{A})$ to\n",
        "    $(\\mathbb{R}, \\mathcal{B}(\\mathbb{R}))$. Note that the probability\n",
        "    measure is irrelevant here. <br> <br> Each random variable induces a\n",
        "    probability measure on $\\mathbb{R}$ by\n",
        "    $P_X(B) = P(X \\in B) = P(X^{-1}(B))$ called the **law** of $X$. <br>\n",
        "    <br>\n",
        "\n",
        "-   **Proposition:**\n",
        "\n",
        "    1.  Let $A \\in \\mathcal{F}$ be an increasing event, then <br>\n",
        "        $\\qquad p \\mapsto \\mathbb{P}_p(A)$ is non-decreasing. <br> <br>\n",
        "    2.  Let $f: \\Omega \\to \\mathbb{R}$ be a measurable, increasing,\n",
        "        nonnegative, bounded function. Then <br>\n",
        "        $\\qquad p \\mapsto \\mathbb{E}_p[f]$ is non-decreasing. <br> <br>\n",
        "\n",
        "    -   Proof:\n",
        "\n",
        "        -   \n",
        "\n",
        "            2.  $\\implies$ 1. by taking $f = \\mathbb{1}_A$.\n",
        "\n",
        "        -   Define $X_p(e) = \\mathbb{1}_{\\{U_e \\leq p\\}}$ so that <br>\n",
        "            $\\qquad E[f(X_p)] = E[f(\\mathbb{1}_{\\{U_e \\leq p\\}})] = p \\cdot f(1) + (1 - p) \\cdot f(0)$\n",
        "            <br>\n",
        "\n",
        "        -   $P(X_p(e) = 1) = p$ and $P(X_p(e) = 0) = 1 - p$ so that the\n",
        "            law associated to the $X_p$s is the same as the one\n",
        "            associated to $\\mathbb{P}_p$. <br>\n",
        "\n",
        "        -   Thus, the expectation of $f$ under the law of $X_p$ is the\n",
        "            same as the expectation of $f$ under $\\mathbb{P}_p$. Indeed,\n",
        "            the change of variable formula gives <br>\n",
        "            $\\qquad E_P[g(Y)] = \\int_{\\Omega} g \\circ Y dP = \\int_{\\mathbb{R}} g d \\mu_{\\text{pushforward of P with respect to Y}} = \\int_{\\mathbb{R}} g dP_Y$,\n",
        "            where <br>\n",
        "\n",
        "            $\\qquad P_Y(B) = P(Y \\in B) = P(Y^{-1}(B))$ is the law of\n",
        "            $Y$. <br>\n",
        "\n",
        "            In our case, this gives <br>\n",
        "\n",
        "            $\\qquad E[f(X_p)] = \\int_{\\mathbb{R}} f dP_{X_p} \\quad (g \\to f, \\text{ } Y \\to X_p)$\n",
        "            which is equal to <br>\n",
        "\n",
        "        -   In the context of the proof, we have $Y = X_p$ and $g = f$\n",
        "            so that <br>\n",
        "            $\\qquad E[f(X_p)] = E_P[f(X_p)] = E_{\\mathbb{P}_p}[f] = E_p[f]$\n",
        "            <br>\n",
        "\n",
        "############################################################################################################ \n",
        "\n",
        "# § Sheet 1\n",
        "\n",
        "<h2>Exercise 1</h2>\n",
        "\n",
        "$\\{A \\xleftrightarrow{} B\\}$ is measurable\n",
        "$\\forall A, B \\subset \\mathbb{Z}^d$, and the function below is\n",
        "measurable.\n",
        "\n",
        "\n",
        "```{=tex}\n",
        "\\begin{aligned}\n",
        "F: \\quad & \\{0, 1\\}^E & \\to     & \\quad N \\cup \\{\\infty\\} \\\\\n",
        "         & \\omega     & \\mapsto & \\quad \\text{size of the cluster containing the origin} = |C_0(\\omega)|.\n",
        "\\end{aligned}\n",
        "```\n",
        "\n",
        "<h2>Exercise 2</h2>\n",
        "\n",
        "The event $\\{0 \\xleftrightarrow{} \\infty\\}$ is measurable.\n",
        "\n",
        "<h2>Exercise 3</h2>\n",
        "\n",
        "Compute the following probabilities:\n",
        "$\\quad P_p(|C_0| = 0), \\quad P_p(|C_0| = 1), \\quad P_p(|C_0| \\geq 1) \\quad \\& \\quad P_p(|C_0| \\geq 1 \\big{|} |C_x| = 0) \\text{ for some } x \\in \\mathbb{Z}^d.$\n",
        "\n",
        "<h2>Exercise 4</h2>\n",
        "\n",
        "On $\\mathbb{Z}^2$, consider the event\n",
        "$$C_{2n,n} = \\{\\exists \\text{ open path from left to right in the box } [0, 2n] \\times [0, n]\\}$$\n",
        "\n",
        "Let $q_n = 1 - P_p(C_{2n,n})$. Show that one of the following holds:\n",
        "\n",
        "-   $\\exists \\varepsilon > 0$ such that $q_n \\geq \\varepsilon$ for all\n",
        "    $n$.\n",
        "-   $\\exists \\varepsilon > 0$ such that $q_n \\leq e^{- \\varepsilon n}$\n",
        "    for all $n$.\n",
        "\n",
        "Based on this result, prove that $p_c < 1$.\n",
        "\n",
        "############################################################################################################ \n",
        "\n",
        "# § Metric Backbone & Spectral Clustering Simulations\n",
        "\n",
        "\n",
        "##  {.sidebar width=\"300px\"}\n"
      ],
      "id": "10cd7cdd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.random.seed(42)\n",
        "\n",
        "input_select_width = 10\n",
        "\n",
        "L = list(range(100, 501, 100))\n",
        "L.insert(0, 50)\n",
        "# L.append(50)\n",
        "\n",
        "ui.input_select(\"n\", \"Number of nodes in each cluster:\",\n",
        "                choices=L,\n",
        "                selected=50,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"d\", \"Number of dimensions & communities:\",\n",
        "                choices=list((2, 3, 4)),\n",
        "                selected=2,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"k\", \"Number of nearest neighbors for graph creation:\",\n",
        "                choices=list((5, 10, 15)),\n",
        "                selected=10,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"n_neighbors\", \"Number of nearest neighbors for spectral clustering:\",\n",
        "                choices=list(range(3, 16)),\n",
        "                selected=4,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"mu_x2\", \"Mean of the second Gaussian with respect to the x-axis:\",\n",
        "                choices=list(range(1, 21)),\n",
        "                selected=3,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "\n",
        "ui.input_select(\"λ\", \"Intensity parameter (N_n ~ Poisson(λ * n)):\",\n",
        "                choices=[1],\n",
        "                selected=1,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"R_1\", \"Big radius for intra-community edges:\",\n",
        "                choices=list(range(1, 11)),\n",
        "                selected=3,\n",
        "                width=input_select_width\n",
        ")\n",
        "\n",
        "ui.input_select(\"R_2\", \"Small radius for inter-community edges:\",\n",
        "                choices=[1, 1.5, 2, 2.5, 3],\n",
        "                selected=[1.5],\n",
        "                width=input_select_width\n",
        ")"
      ],
      "id": "88ff49cf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Column\n"
      ],
      "id": "6cb16cf3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: community-detection-on-Euclidean-graphs-FUNCTIONS\n",
        "\n",
        "def euclidean_distance(tuple_1, tuple_2):\n",
        "    return np.linalg.norm(np.array(tuple_1) - np.array(tuple_2))\n",
        "\n",
        "\n",
        "def φ(R):\n",
        "    return lambda r: 1 if r <= R else 0\n",
        "\n",
        "\n",
        "def f(f_r):\n",
        "    return lambda G_distance, u_idx, v_idx: f_r(euclidean_distance(tuple_1=G_distance.nodes[u_idx]['pos'], tuple_2=G_distance.nodes[v_idx]['pos']))"
      ],
      "id": "community-detection-on-Euclidean-graphs-FUNCTIONS",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Inter- & Intra-Community Proportion Functions\n",
        "\n",
        "\n",
        "def get_inter_proportion(G):\n",
        "  \n",
        "  nominator = 0\n",
        "  \n",
        "  for u, v in G.edges():\n",
        "    if G.nodes[u]['community'] != G.nodes[v]['community']:\n",
        "      nominator += 1\n",
        "      \n",
        "  denominator = G.number_of_edges()\n",
        "      \n",
        "  res = nominator / denominator\n",
        "  \n",
        "  return res\n",
        "\n",
        "\n",
        "def get_intra_proportion(G):\n",
        "  return 1 - get_inter_proportion(G)"
      ],
      "id": "Inter---Intra-Community-Proportion-Functions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: functions to produce samples\n",
        "\n",
        " \n",
        "# def produce_gaussian_samples(n, d, mu_x2, SEED=global_SEED):\n",
        "# \n",
        "#     n_rows = n * d\n",
        "#     samples = np.empty((n_rows, d + 1))\n",
        "#     samples[:, 0] = np.arange(len(samples))\n",
        "# \n",
        "#     col_slice = slice(1, samples.shape[1] + 1)\n",
        "# \n",
        "#     rng = np.random.default_rng(42)\n",
        "#     idx = 0\n",
        "#     for last_row in range(0, n_rows, n):  # step size is n\n",
        "#         mean_val = mu_x2 * idx\n",
        "#         row_slice = slice(last_row, last_row + n)\n",
        "#         samples[row_slice, col_slice] = rng.multivariate_normal(\n",
        "#             mean=np.insert(np.zeros(d - 1), 0, mean_val), cov=np.eye(d), size=n\n",
        "#         )\n",
        "#         idx += 1\n",
        "# \n",
        "#     return samples\n",
        "# \n",
        "# \n",
        "# def produce_uniform_samples(n, d, SEED=global_SEED):\n",
        "# \n",
        "#     n_nodes = n * d\n",
        "#     d_root_n = n_nodes ** (1 / d)\n",
        "# \n",
        "#     samples        = np.empty((n_nodes, d + 1))\n",
        "#     samples[:, 0]  = np.arange(len(samples))\n",
        "#     \n",
        "#     rng = np.random.default_rng(SEED)\n",
        "#     samples[:, 1:] = d_root_n  * rng.uniform(size=(n_nodes, d))  # type(.)    : np.ndarray\n",
        "#                                                                  # np.shape(.): (N_n, d)\n",
        "#     return samples\n",
        "  \n",
        "\n",
        "def produce_samples(n, d , type_samples, mu_x2=None, SEED=global_SEED):\n",
        "    \n",
        "    rng = np.random.default_rng(42)\n",
        "  \n",
        "    n_rows = n * d  # one row per node\n",
        "    samples = np.empty((n_rows, d + 1))\n",
        "    samples[:, 0] = np.arange(len(samples))\n",
        "    \n",
        "    \n",
        "    if type_samples == \"gaussian\":\n",
        "    \n",
        "        col_slice = slice(1, samples.shape[1] + 1)\n",
        "    \n",
        "        idx = 0\n",
        "        for last_row in range(0, n_rows, n):  # step size is n\n",
        "            mean_val = mu_x2 * idx\n",
        "            row_slice = slice(last_row, last_row + n)\n",
        "            samples[row_slice, col_slice] = rng.multivariate_normal(\n",
        "                mean=np.insert(np.zeros(d - 1), 0, mean_val), cov=np.eye(d), size=n\n",
        "            )\n",
        "            idx += 1\n",
        "    \n",
        "    \n",
        "    elif type_samples == \"uniform\":\n",
        "      \n",
        "        samples[:, 1:] = d_root_n  * rng.uniform(size=(n_nodes, d))  # type(.)    : np.ndarray\n",
        "                                                                     # np.shape(.): (N_n, d)\n",
        "      \n",
        "    else:\n",
        "        raise ValueError(\"type_samples must be either 'gaussian' or 'uniform'\")\n",
        "      \n",
        "    \n",
        "    return samples"
      ],
      "id": "functions-to-produce-samples",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: functions to produce distance graphs\n",
        "\n",
        "\n",
        "def produce_G_distance(n, k, samples):\n",
        "    \n",
        "    G_distance = nx.Graph()\n",
        "\n",
        "    d = {int(row[0]): (row[1], row[2]) for row in samples}\n",
        "\n",
        "    for node, coord in d.items():\n",
        "        community = 0\n",
        "            \n",
        "        if node + 1 > n:\n",
        "            community = 1\n",
        "        \n",
        "        G_distance.add_node(node, pos=coord, community=community)\n",
        "\n",
        "\n",
        "\n",
        "    col_slice = slice(1, samples.shape[1] + 1)\n",
        "\n",
        "    W = get_Gaussian_weight_matrix(samples[:, col_slice], k)\n",
        "\n",
        "    for i in range(2 * n):\n",
        "        for j in range(i + 1, 2 * n):\n",
        "            w = W[i, j]\n",
        "            if w > 0:\n",
        "                G_distance.add_edge(i, j, weight=1 / w - 1)\n",
        "\n",
        "    return G_distance\n",
        "\n",
        "\n",
        "def produce_G_distance_ABBE(n, n_communities, k, samples, F):\n",
        "    n_nodes = n * n_communities\n",
        "    d = {int(row[0]): (row[1], row[2]) for row in samples}\n",
        "\n",
        "    G_distance_ABBE = nx.Graph()\n",
        "    G_distance_ABBE.add_nodes_from(d.keys())\n",
        "    nx.set_node_attributes(G_distance_ABBE, d, 'pos')\n",
        "\n",
        "    community_labels = np.array(range(1, n_communities + 1))\n",
        "    rng = np.random.default_rng(42)\n",
        "    nx.set_node_attributes(G_distance_ABBE, {node: rng.choice(community_labels) for node in G_distance_ABBE.nodes}, 'community')\n",
        "\n",
        "    edges_to_add = [\n",
        "      (u_idx, v_idx) for u_idx in range(n_nodes) for v_idx in range(u_idx + 1, n_nodes) if F(G_distance_ABBE, u_idx, v_idx) == 1\n",
        "    ]\n",
        "    \n",
        "    G_distance_ABBE.add_edges_from(edges_to_add)\n",
        "\n",
        "    return G_distance_ABBE"
      ],
      "id": "functions-to-produce-distance-graphs",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: draw function\n",
        "\n",
        "\n",
        "def draw(G, MB, samples, n_neighbors, axs, n_clusters, L_idx=[0, 1], affinity='precomputed'):\n",
        "  \n",
        "    pos = nx.get_node_attributes(G, 'pos')  # Extract node positions\n",
        "    \n",
        "    true_labels = list(nx.get_node_attributes(G, 'community').values())\n",
        "    true_colors = ['red' if label == true_labels[0] else 'blue' for label in true_labels]\n",
        "\n",
        "    col_slice = slice(1, samples.shape[1] + 1)\n",
        "\n",
        "    SC = SpectralClustering(n_clusters=n_clusters, affinity=affinity)\n",
        "    \n",
        "    def get_predColors_similarity(samples, col_slice, n_neighbors, true_labels, b_original=True, MB=None):\n",
        "      \n",
        "        A = None\n",
        "        \n",
        "        if b_original:\n",
        "            A = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)\n",
        "        else:\n",
        "            A = nx.adjacency_matrix(MB, nodelist=[i for i in range(MB.number_of_nodes())], weight='proximity')\n",
        "            A = scipy.sparse.csr_matrix(A)\n",
        "            \n",
        "        pred_labels = SC.fit_predict(A)\n",
        "        pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]\n",
        "        similarity  = adjusted_rand_score(true_labels, pred_labels)\n",
        "        \n",
        "        if b_original:\n",
        "            print(f\"Adjusted Rand Score on Original Graph: {similarity * 100}\")\n",
        "        else:\n",
        "            print(f\"Adjusted Rand Score on MB : {similarity * 100}\")\n",
        "            \n",
        "        return pred_colors, similarity\n",
        "      \n",
        "    pred_colors_original, similarity_original = get_predColors_similarity(samples, col_slice, n_neighbors, true_labels)\n",
        "    pred_colors_mb, similarity_mb = get_predColors_similarity(\n",
        "      samples=None, col_slice=None, n_neighbors=None, true_labels=true_labels, b_original=False, MB=MB\n",
        "    )\n",
        "\n",
        "\n",
        "\n",
        "    nx.draw(G, pos, node_color=true_colors, node_size=5, ax=axs[L_idx[0], 0], edge_color='lightgray')\n",
        "    nx.draw(MB, pos, node_color=true_colors, node_size=5, ax=axs[L_idx[0], 1], edge_color='lightgray')\n",
        "    \n",
        "    nx.draw(G, pos, node_color=pred_colors_original, node_size=5, ax=axs[L_idx[1], 0], edge_color='lightgray')\n",
        "    nx.draw(MB, pos, node_color=pred_colors_mb, node_size=5, ax=axs[L_idx[1], 1], edge_color='lightgray')\n",
        "    \n",
        "    return similarity_original, similarity_mb"
      ],
      "id": "draw-function",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "@render.plot\n",
        "def normals_nNodes_dDimensions_PLOT():\n",
        "    \n",
        "    n           = int(input.n())\n",
        "    d           = int(input.d())\n",
        "    n_clusters  = d\n",
        "    k           = int(input.k())\n",
        "    mu_x2       = float(input.mu_x2())\n",
        "    n_neighbors = int(input.n_neighbors())\n",
        "    λ           = int(input.λ())\n",
        "\n",
        "    R_1         = float(input.R_1())  \n",
        "    R_2         = float(input.R_2())\n",
        "    R_1, R_2 = max(R_1, R_2), min(R_1, R_2)\n",
        "    f_in_r  = φ(R_1)\n",
        "    f_out_r = φ(R_2)\n",
        "    f_in  = f(f_in_r)\n",
        "    f_out = f(f_out_r)\n",
        "\n",
        "\n",
        "    def F(G_distance, u_idx, v_idx, f_in=f_in, f_out=f_out):\n",
        "        if G_distance.nodes[u_idx]['community'] == G_distance.nodes[v_idx]['community']:\n",
        "            return f_in(G_distance, u_idx, v_idx)\n",
        "        else:\n",
        "            return f_out(G_distance, u_idx, v_idx)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    λ_n = λ * n\n",
        "    N_n = λ_n  # N_n = E[poisson(λ_n)], type: int\n",
        "\n",
        "\n",
        "    # Generate samples separately\n",
        "    samples_gaussian = produce_samples(n, d, mu_x2, type_samples=\"gaussian\")\n",
        "\n",
        "    # Update G_distance separately\n",
        "    G_distance = produce_G_distance(n, k, samples_gaussian)\n",
        "    mb_igraph = get_metric_backbone_igraph(G_distance)\n",
        "\n",
        "    # Now handle plotting\n",
        "    fig, axs = plt.subplots(4, 2, figsize=(24, 12))\n",
        "    \n",
        "    similarity_original, similarity_mb = draw(G_distance, mb_igraph, samples_gaussian, n_neighbors, axs, n_clusters)\n",
        "\n",
        "    ############## ABBE ################\n",
        "    \n",
        "    SC = SpectralClustering(n_clusters=n_clusters, affinity='precomputed')\n",
        "\n",
        "    samples_uniform = produce_samples(n, d, type_samples=\"uniform\")\n",
        "    G_distance_ABBE = produce_G_distance_ABBE(n, d, k, samples_uniform, F)\n",
        "\n",
        "    col_slice = slice(1, samples_uniform.shape[1] + 1)\n",
        "\n",
        "    W = get_Gaussian_weight_matrix(samples_uniform[:, col_slice], k)\n",
        "\n",
        "    edges = list(G_distance_ABBE.edges())\n",
        "    weights = {(u, v): 1 / W[u, v] - 1 if W[u, v] > 0 else float('inf') for u, v in edges}\n",
        "    nx.set_edge_attributes(G_distance_ABBE, weights, 'weight')\n",
        "\n",
        "    mb_igraph_ABBE = get_metric_backbone_igraph(G_distance_ABBE)\n",
        "\n",
        "    similarity_original_ABBE, similarity_mb_ABBE = draw(G_distance_ABBE, mb_igraph_ABBE, samples_uniform, n_neighbors, axs, n_clusters, L_idx=[2, 3])\n",
        "\n",
        "    # Helper functions to add legend\n",
        "    def produce_patch_gaussian(color, mu_x):\n",
        "        return plt.Line2D(\n",
        "            [0],\n",
        "            [0], \n",
        "            marker='o', \n",
        "            color='w', \n",
        "            markerfacecolor=color, \n",
        "            markersize=8, \n",
        "            label=f'X-mean: {round(mu_x)}'\n",
        "        )\n",
        "\n",
        "\n",
        "    def produce_patch_ABBE(color, plus_or_minus_one):\n",
        "        return plt.Line2D(\n",
        "            [0],\n",
        "            [0], \n",
        "            marker='o', \n",
        "            color='w', \n",
        "            markerfacecolor=color, \n",
        "            markersize=8, \n",
        "            label=f'Community label: {plus_or_minus_one}'\n",
        "        )\n",
        "\n",
        "\n",
        "    for i in range(4):\n",
        "        for j in range(2):\n",
        "            ax = axs[i, j]\n",
        "            ax.set_xlabel('X-axis')\n",
        "            ax.set_ylabel('Y-axis')\n",
        "            ax.axis('equal')\n",
        "            ax.axis('on')\n",
        "            ax.tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)\n",
        "            if i < 2:\n",
        "                ax.legend(handles=[produce_patch_gaussian('red', 0), produce_patch_gaussian('blue', mu_x2)])\n",
        "            else:\n",
        "                ax.legend(handles=[produce_patch_ABBE('red', 1), produce_patch_ABBE('blue', -1)])\n",
        "\n",
        "\n",
        "\n",
        "    axs[0, 0].set_title(f'Gaussian Samples with {n} nodes in each cluster, inter-proportion: {get_inter_proportion(G_distance) * 100:.2f}%')\n",
        "    axs[0, 1].set_title(f'Metric Backbone, inter-proportion: {get_inter_proportion(mb_igraph) * 100:.2f}%')\n",
        "    \n",
        "    axs[1, 0].set_title(f'SC: Gaussian Samples with {n} nodes in each cluster, ARI: {similarity_original * 100:.2f}%')\n",
        "    axs[1, 1].set_title(f'SC: Metric Backbone, ARI: {similarity_mb * 100:.2f}%')\n",
        "    \n",
        "    \n",
        "    axs[2, 0].set_title(f'ABBE original {G_distance_ABBE.number_of_edges()} edges, inter-proportion: {get_inter_proportion(G_distance_ABBE) * 100:.2f}%')\n",
        "    axs[2, 1].set_title(f'ABBE MB {mb_igraph_ABBE.number_of_edges()} edges, inter-proportion: {get_inter_proportion(mb_igraph_ABBE) * 100:.2f}%')\n",
        "    axs[3, 0].set_title(f'SC: ABBE original, ARI: {similarity_original_ABBE * 100:.2f}%')\n",
        "    axs[3, 1].set_title(f'SC: ABBE MB, ARI: {similarity_mb_ABBE * 100:.2f}%')\n",
        "    \n",
        "    \n",
        "    fig, axs = plt.subplots(4, 2, figsize=(24, 12))\n",
        "    \n",
        "    similarity_original, similarity_mb = draw(G_distance, mb_igraph, samples_gaussian, n_neighbors, axs, n_clusters)\n",
        "\n",
        "    ############## ABBE ################\n",
        "    \n",
        "    SC = SpectralClustering(n_clusters=n_clusters, affinity='precomputed')\n",
        "\n",
        "    samples_uniform = produce_uniform_samples(n, d, 42)\n",
        "    G_distance_ABBE = produce_G_distance_ABBE(n, d, k, samples_uniform, F)\n",
        "\n",
        "    col_slice = slice(1, samples_uniform.shape[1] + 1)\n",
        "\n",
        "    W = get_Gaussian_weight_matrix(samples_uniform[:, col_slice], k)\n",
        "\n",
        "    edges = list(G_distance_ABBE.edges())\n",
        "    weights = {(u, v): 1 / W[u, v] - 1 if W[u, v] > 0 else float('inf') for u, v in edges}\n",
        "    nx.set_edge_attributes(G_distance_ABBE, weights, 'weight')\n",
        "\n",
        "    mb_igraph_ABBE = get_metric_backbone_igraph(G_distance_ABBE)\n",
        "\n",
        "    similarity_original_ABBE, similarity_mb_ABBE = draw(G_distance_ABBE, mb_igraph_ABBE, samples_uniform, n_neighbors, axs, n_clusters, L_idx=[2, 3])\n",
        "\n",
        "    # Helper functions to add legend\n",
        "    def produce_patch_gaussian(color, mu_x):\n",
        "        return plt.Line2D(\n",
        "            [0],\n",
        "            [0], \n",
        "            marker='o', \n",
        "            color='w', \n",
        "            markerfacecolor=color, \n",
        "            markersize=8, \n",
        "            label=f'X-mean: {round(mu_x)}'\n",
        "        )\n",
        "\n",
        "\n",
        "    def produce_patch_ABBE(color, plus_or_minus_one):\n",
        "        return plt.Line2D(\n",
        "            [0],\n",
        "            [0], \n",
        "            marker='o', \n",
        "            color='w', \n",
        "            markerfacecolor=color, \n",
        "            markersize=8, \n",
        "            label=f'Community label: {plus_or_minus_one}'\n",
        "        )\n",
        "\n",
        "\n",
        "    for i in range(4):\n",
        "        for j in range(2):\n",
        "            ax = axs[i, j]\n",
        "            ax.set_xlabel('X-axis')\n",
        "            ax.set_ylabel('Y-axis')\n",
        "            ax.axis('equal')\n",
        "            ax.axis('on')\n",
        "            ax.tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)\n",
        "            if i < 2:\n",
        "                ax.legend(handles=[produce_patch_gaussian('red', 0), produce_patch_gaussian('blue', mu_x2)])\n",
        "            else:\n",
        "                ax.legend(handles=[produce_patch_ABBE('red', 1), produce_patch_ABBE('blue', -1)])\n",
        "\n",
        "\n",
        "\n",
        "    axs[0, 0].set_title(f'Gaussian Samples with {n} nodes in each cluster, inter-proportion: {get_inter_proportion(G_distance) * 100:.2f}%')\n",
        "    axs[0, 1].set_title(f'Metric Backbone, inter-proportion: {get_inter_proportion(mb_igraph) * 100:.2f}%')\n",
        "    \n",
        "    axs[1, 0].set_title(f'SC: Gaussian Samples with {n} nodes in each cluster, ARI: {similarity_original * 100:.2f}%')\n",
        "    axs[1, 1].set_title(f'SC: Metric Backbone, ARI: {similarity_mb * 100:.2f}%')\n",
        "    \n",
        "    \n",
        "    axs[2, 0].set_title(f'ABBE original {G_distance_ABBE.number_of_edges()} edges, inter-proportion: {get_inter_proportion(G_distance_ABBE) * 100:.2f}%')\n",
        "    axs[2, 1].set_title(f'ABBE MB {mb_igraph_ABBE.number_of_edges()} edges, inter-proportion: {get_inter_proportion(mb_igraph_ABBE) * 100:.2f}%')\n",
        "    axs[3, 0].set_title(f'SC: ABBE original, ARI: {similarity_original_ABBE * 100:.2f}%')\n",
        "    axs[3, 1].set_title(f'SC: ABBE MB, ARI: {similarity_mb_ABBE * 100:.2f}%')"
      ],
      "id": "8dcbd19a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Conclusions\n",
        "\n",
        "- Spectral clustering performs very poorly on ABBE graphs. \n",
        "\n",
        "\n",
        "# § graph\n"
      ],
      "id": "cf13855e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "fig, axs = plt.subplots(2, 1, figsize=(6, 12))\n",
        "\n",
        "n           = 100\n",
        "d           = 2\n",
        "n_clusters  = d\n",
        "k           = 10\n",
        "n_neighbors = 4\n",
        "λ           = 1\n",
        "\n",
        "mu_x2_grid  = np.arange(1, 5.1, 0.5).tolist()\n",
        "res_G = []\n",
        "res_MB = []\n",
        "\n",
        "for mu_x2 in mu_x2_grid:\n",
        "    samples = produce_gaussian_samples(n, d, mu_x2)\n",
        "    G = produce_G_distance(n, k, samples)\n",
        "    MB = get_metric_backbone_igraph(G)\n",
        "    \n",
        "    pos = nx.get_node_attributes(G, 'pos')  # Extract node positions\n",
        "    \n",
        "    true_labels = list(nx.get_node_attributes(G, 'community').values())\n",
        "    true_colors = ['red' if label == true_labels[0] else 'blue' for label in true_labels]\n",
        "    \n",
        "    col_slice = slice(1, samples.shape[1] + 1)\n",
        "    \n",
        "    SC = SpectralClustering(n_clusters=n_clusters, affinity='precomputed')\n",
        "    \n",
        "    A = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)\n",
        "        \n",
        "    pred_labels = SC.fit_predict(A)\n",
        "    pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]\n",
        "    similarity  = adjusted_rand_score(true_labels, pred_labels)\n",
        "    \n",
        "    res_G.append(similarity)\n",
        "    \n",
        "    A = nx.adjacency_matrix(MB, nodelist=[i for i in range(MB.number_of_nodes())], weight='proximity')\n",
        "    A = scipy.sparse.csr_matrix(A)\n",
        "    \n",
        "    pred_labels = SC.fit_predict(A)\n",
        "    pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]\n",
        "    similarity  = adjusted_rand_score(true_labels, pred_labels)\n",
        "    \n",
        "    res_MB.append(similarity)\n",
        "    \n",
        "ax = axs[0]    \n",
        "ax.plot(mu_x2_grid, res_G)\n",
        "ax.set_title('Original Graph')\n",
        "ax.set_xlabel('Mean of the second Gaussian with respect to the x-axis')\n",
        "ax.set_ylabel('ARI')\n",
        "\n",
        "ax = axs[1]\n",
        "ax.plot(mu_x2_grid, res_MB)\n",
        "ax.set_title('Metric Backbone')\n",
        "ax.set_xlabel('Mean of the second Gaussian with respect to the x-axis')\n",
        "ax.set_ylabel('ARI')\n"
      ],
      "id": "f8017f86",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# § Module Dependencies"
      ],
      "id": "0d3d782c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#print(f\"Adjusted Rand Score on origin: {similarity * 100:.2f}%\")\n",
        "\n",
        "# Spectral Clustering (Original VS Metric Backbone)\n",
        "\n",
        "# -   SSL: semi-supervised learning\n",
        "# \n",
        "#     -   time to build the metric backbone\n",
        "# \n",
        "# -   TSC: thresholding-based subspaces clustering\n",
        "# \n",
        "# -   helper_plots: plot_TSC_k"
      ],
      "id": "adb2a82c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{mermaid}\n",
        "flowchart LR\n",
        "    A[clustering.py] --> B[community_experiments_plots.py]\n",
        "    A --> C[community_experiments_tables.py]\n",
        "    C --> D[helper_plots.py]\n",
        "    E[metric_backbone.py] --> F[SSL.py]\n",
        "    E --> G[graph_builder.py]\n",
        "    G --> F\n",
        "    G --> H[TSC.py]\n",
        "    G --> B\n",
        "    G --> C\n",
        "    G --> D\n",
        "    G --> I[datasets.py]\n",
        "    I --> J[metrics.py]\n",
        "    I --> F\n",
        "    D --> F\n",
        "    D --> H\n",
        "    J --> H\n",
        "    J --> B\n",
        "    I --> B\n",
        "    J --> C\n",
        "    I --> C\n",
        "    K[EffectiveResistanceSampling/Network.py] --> G\n",
        "    J --> D\n",
        "```\n",
        "\n",
        "\n",
        "# § Proof of THM 2.1\n",
        "\n",
        "## Change of variables formula from wikipedia\n",
        "\n",
        "$$\\int_{X_2} g \\text{ } d(f_*\\mu) = \\int_{X_1} g \\circ f \\text{ } d\\mu$$\n",
        "\n",
        "for\n",
        "\n",
        "•⁠ ⁠$f: (X_1, \\Sigma_1) \\to (X_2, \\Sigma_2)$,\n",
        "\n",
        "•⁠ ⁠$g: (X_2, \\Sigma_2) \\to (\\mathbb{R}, \\mathcal{B}_\\mathbb{R})$,\n",
        "\n",
        "•⁠ ⁠$\\mu: \\Sigma_1 \\to [0, \\infty]$ a measure,\n",
        "\n",
        "•⁠ ⁠$f_\\mu: \\Sigma_2 \\to [0, \\infty]$ a measure defined by\n",
        "$f_\\mu(A) = \\mu(f^{-1}(A))$, the pushforward measure of $\\mu$ with\n",
        "respect to $f$.\n",
        "\n",
        "## Application to the proof of THM 2.1\n",
        "\n",
        "•⁠ ⁠We replace the professor's $f$ by Grimmett's $N$.\n",
        "\n",
        "We have\n",
        "\n",
        "•⁠ ⁠$\\mu: \\mathcal{F} \\to [0, \\infty]$ is a measure on $[0, 1]^E$.\n",
        "\n",
        "•⁠ ⁠$X: ([0, 1]^E, \\mathbb{B(\\cdot)})\\to (\\Omega, \\mathcal{F})$ meausrable\n",
        "$\\implies$ \\* $(X_1, \\Sigma_1) = ([0, 1]^E$, $\\mathbb{B(\\cdot)}$), \\*\n",
        "$(X_2, \\Sigma_2) = (\\Omega, \\mathcal{F})$, \\* $f = X$, \\* $g = N$,\n",
        "\n",
        "So that:\n",
        "\n",
        "$$\\int_{\\Omega} N \\text{ } d(X_*\\mu) = \\int_{[0, 1]^E} N \\circ X \\text{ } d\\mu$$\n",
        "\n",
        "Clearly,\n",
        "\n",
        "$$E[N \\circ X] = \\int_{[0, 1]^E} N \\circ X \\text{ } d\\mu.$$\n",
        "\n",
        "Furthermore, if we consider\n",
        "\n",
        "•⁠ ⁠$P_p: \\mathcal{F} \\to [0, 1]$, •⁠\n",
        "⁠$A = \\{w(e_1) = u_1, \\ldots, w(e_k) = u_k\\} \\in \\mathcal{F}$\n",
        "\n",
        "we have:\n",
        "\n",
        "•⁠\n",
        "⁠$P_p(A) = p^k(1-p)^{|E| - k} = [0, p]^k \\times [p, 1]^{|E| - k} = \\int_{[0, p]^k \\times [p, 1]^{|E| - k}} d\\lambda = \\int_{X^{-1}(A)} d\\lambda = \\mu(X^{-1}(A))= X_*(\\mu)(A)$.\n",
        "\n",
        "so that we also have\n",
        "\n",
        "•⁠\n",
        "⁠$E_p[N] = \\int_{\\Omega} N \\text{ } dP_p = \\int_{\\Omega} N \\text{ } d(X_*\\mu)$,\n",
        "\n",
        "allowing us to conclude that\n",
        "\n",
        "$$E_p[N] = E[N \\circ X].$$\n",
        "\n",
        "•⁠ ⁠Note that we are able to concentrate on sets such as\n",
        "$A = \\{w(e_1) = u_1, \\ldots, w(e_k) = u_k\\}$ because the measure $P_p$\n",
        "is characterized by its output on such setss.\n",
        "\n",
        "# § Instructions to deploy website\n",
        "\n",
        "-   When preview yields the desired result in VsCode, compress the\n",
        "    directory that contains \"script.qmd\" & \"app.py\" and upload to\n",
        "    RStudio in posit.cloud\n",
        "\n",
        "-   In posit.cloud's RStudio, do: script.qmd \\> Run Document (you will\n",
        "    not get a good result, don't worry)\n",
        "\n",
        "-   rsconnect add --account rfua --name rfua --token\n",
        "    81C1E677FB6E5544A763A83C69AF49E9 --secret\n",
        "    EAtsm+UuJrsMEwDkmLppzkl0Q8fMZi9fnR3y4p+C\n",
        "\n",
        "-   rsconnect deploy shiny -n rfua . (This can take up to three minutes)\n",
        "\n",
        "-   Possible to develop directly from posit.cloud's RStudio by doing:\n",
        "\n",
        "    -   script.qmd \\> Run Document\n",
        "    -   app.py \\> Run App\n",
        "    -   this makes it possible to see intermediary results."
      ],
      "id": "7252f4be"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/cloud/python/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}