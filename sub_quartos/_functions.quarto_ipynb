{
  "cells": [
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: def_get_Gaussian_weight_matrix\n",
        "\n",
        "def get_Gaussian_weight_matrix(X, n_neighbors):\n",
        "    Z = gl.weightmatrix.knn(X, n_neighbors)  # Gaussian similarity measure\n",
        "    A = (Z + Z.T) / 2\n",
        "    return A"
      ],
      "id": "def_get_Gaussian_weight_matrix",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: def_get_metric_backbone_igraph\n",
        "\n",
        "def get_metric_backbone_igraph(D):\n",
        "    \"\"\"\n",
        "     :param D: networkx distance graph (with weight and proximity edge attribute)\n",
        "     :return: Networkx Metric Backbone subgraph of D\n",
        "    \"\"\"\n",
        "    D_ig = ig.Graph.from_networkx(D)\n",
        "    distances = D_ig.distances(weights='weight')\n",
        "\n",
        "    G = nx.Graph(D)\n",
        "    G.remove_edges_from([(x, y) for x, y, w in G.edges.data('weight') if w > distances[x][y]])\n",
        "    return G"
      ],
      "id": "def_get_metric_backbone_igraph",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: community_detection_on_Euclidean_graphs_FUNCTIONS\n",
        "\n",
        "def euclidean_distance(tuple_1, tuple_2):\n",
        "    return np.linalg.norm(np.array(tuple_1) - np.array(tuple_2))\n",
        "\n",
        "\n",
        "def Ï†(R):\n",
        "    return lambda r: 1 if r <= R else 0\n",
        "\n",
        "\n",
        "def f(f_r):\n",
        "    return lambda G_distance, u_idx, v_idx: f_r(euclidean_distance(tuple_1=G_distance.nodes[u_idx]['pos'], tuple_2=G_distance.nodes[v_idx]['pos']))\n",
        "  \n",
        "\n",
        "def indicator(condition):\n",
        "    return 1 if condition else 0\n",
        "  \n",
        "\n",
        "def make_F(f_in, f_out):\n",
        "    return lambda G, u_idx, v_idx: indicator(G.nodes[u_idx]['community'] == G.nodes[v_idx]['community']) * f_in(G, u_idx, v_idx) + (1 - indicator(G.nodes[u_idx]['community'] == G.nodes[v_idx]['community'])) * f_out(G, u_idx, v_idx)\n"
      ],
      "id": "community_detection_on_Euclidean_graphs_FUNCTIONS",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: inter_and_intra_community_proportion_functions\n",
        "\n",
        "\n",
        "def get_inter_proportion(G):\n",
        "  \n",
        "  nominator = 0\n",
        "  \n",
        "  for u, v in G.edges():\n",
        "    if G.nodes[u]['community'] != G.nodes[v]['community']:\n",
        "      nominator += 1\n",
        "      \n",
        "  denominator = G.number_of_edges()\n",
        "      \n",
        "  res = nominator / denominator\n",
        "  \n",
        "  return res\n",
        "\n",
        "\n",
        "def get_intra_proportion(G):\n",
        "  return 1 - get_inter_proportion(G)"
      ],
      "id": "inter_and_intra_community_proportion_functions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: functions_to_produce_samples\n",
        "\n",
        " \n",
        "def produce_samples(n, d , type_samples, mu_x2=None, SEED=global_SEED):\n",
        "    \n",
        "    rng = np.random.default_rng(SEED)\n",
        "  \n",
        "    n_rows = n * d  # one row per node\n",
        "    samples = np.empty((n_rows, d + 1))\n",
        "    samples[:, 0] = np.arange(len(samples))\n",
        "    \n",
        "    \n",
        "    if type_samples == \"gaussian\":\n",
        "    \n",
        "        col_slice = slice(1, samples.shape[1] + 1)\n",
        "    \n",
        "        idx = 0\n",
        "        for last_row in range(0, n_rows, n):  # step size is n\n",
        "            mean_val = mu_x2 * idx\n",
        "            row_slice = slice(last_row, last_row + n)\n",
        "            samples[row_slice, col_slice] = rng.multivariate_normal(\n",
        "                mean=np.insert(np.zeros(d - 1), 0, mean_val), cov=np.eye(d), size=n\n",
        "            )\n",
        "            idx += 1\n",
        "    \n",
        "    \n",
        "    elif type_samples == \"uniform\":\n",
        "      \n",
        "        d_root_n = n_rows ** (1 / d)\n",
        "        samples[:, 1:] = d_root_n  * rng.uniform(size=(n_rows, d))  # type(.)    : np.ndarray\n",
        "                                                                     # np.shape(.): (N_n, d)\n",
        "      \n",
        "    else:\n",
        "        raise ValueError(\"type_samples must be either 'gaussian' or 'uniform'\")\n",
        "      \n",
        "    \n",
        "    return samples"
      ],
      "id": "functions_to_produce_samples",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: def_produce_distance_graph\n",
        "\n",
        "def produce_distance_graph(samples, n, n_communities, n_neighbors=None, framework='gaussian', SEED=global_SEED, F=None, R1=None, R2=None):\n",
        "  \n",
        "    rng = np.random.default_rng(SEED)\n",
        "  \n",
        "    G = nx.Graph()\n",
        "    \n",
        "    d = {int(row[0]): (row[1], row[2]) for row in samples}\n",
        "    \n",
        "    G.add_nodes_from(d.keys())\n",
        "    nx.set_node_attributes(G, d, 'pos')\n",
        "    \n",
        "    n_nodes = n * n_communities\n",
        "        \n",
        "    if framework == 'gaussian':\n",
        "        nx.set_node_attributes(G, {node: 1 if node + 1 > n else 0 for node in G.nodes}, 'community')\n",
        "    \n",
        "        col_slice = slice(1, samples.shape[1] + 1)\n",
        "    \n",
        "        W = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)\n",
        "    \n",
        "        for i in range(n_nodes):\n",
        "            for j in range(i + 1, n_nodes):\n",
        "                w = W[i, j]\n",
        "                if w > 0:\n",
        "                    G.add_edge(i, j, weight=1 / w - 1)\n",
        "                \n",
        "    \n",
        "    elif framework == 'ABBE':\n",
        "    \n",
        "        community_labels = np.array(range(1, n_communities + 1))\n",
        "        nx.set_node_attributes(G, {node: rng.choice(community_labels) for node in G.nodes}, 'community')\n",
        "        \n",
        "        \n",
        "        edges_to_add = [(u_idx, v_idx) for u_idx in range(n_nodes) for v_idx in range(u_idx + 1, n_nodes) if F(G, u_idx, v_idx) == 1]\n",
        "        \n",
        "        G.add_edges_from(edges_to_add)\n",
        "        \n",
        "    elif framework == 'hybrid':\n",
        "        nx.set_node_attributes(G, {node: 1 if node + 1 > n else 0 for node in G.nodes}, 'community')\n",
        "        \n",
        "        \n",
        " \n",
        "        edges_to_add = [(u_idx, v_idx) for u_idx in range(n_nodes) for v_idx in range(u_idx + 1, n_nodes) if F(G, u_idx, v_idx) == 1]\n",
        "        \n",
        "        G.add_edges_from(edges_to_add)\n",
        "\n",
        "    return G\n"
      ],
      "id": "def_produce_distance_graph",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: def_produce_patch\n",
        "\n",
        "\n",
        "# Helper functions to add legend\n",
        "def produce_patch(color, framework='gaussian', mu_x2=None, plus_or_minus_one=None):\n",
        "  if framework == 'gaussian':\n",
        "    return plt.Line2D(\n",
        "        [0],\n",
        "        [0], \n",
        "        marker='o', \n",
        "        color='w', \n",
        "        markerfacecolor=color, \n",
        "        markersize=8, \n",
        "        label=f'X-mean: {round(mu_x2)}'\n",
        "    )\n",
        "  elif framework == 'ABBE':\n",
        "    return plt.Line2D(\n",
        "        [0],\n",
        "        [0], \n",
        "        marker='o', \n",
        "        color='w', \n",
        "        markerfacecolor=color, \n",
        "        markersize=8, \n",
        "        label=f'Community label: {plus_or_minus_one}'\n",
        "    )\n"
      ],
      "id": "def_produce_patch",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "#| label: def_get_predColors_similarity_def_draw\n",
        "\n",
        "\n",
        "def get_predColors_similarity(samples, col_slice, n_neighbors, true_labels, b_original=True, MB=None):\n",
        "  \n",
        "    A = None\n",
        "    \n",
        "    if b_original:\n",
        "        A = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)\n",
        "    else:\n",
        "        A = nx.adjacency_matrix(MB, nodelist=[i for i in range(MB.number_of_nodes())], weight='proximity')\n",
        "        A = scipy.sparse.csr_matrix(A)\n",
        "        \n",
        "    pred_labels = SC.fit_predict(A)\n",
        "    pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]\n",
        "    similarity  = adjusted_rand_score(true_labels, pred_labels)\n",
        "    \n",
        "    if b_original:\n",
        "        print(f\"Adjusted Rand Score on Original Graph: {similarity * 100}\")\n",
        "    else:\n",
        "        print(f\"Adjusted Rand Score on MB : {similarity * 100}\")\n",
        "        \n",
        "    return pred_colors, similarity\n",
        "\n",
        "\n",
        "def draw(G, MB, samples, n_neighbors, axs, n_clusters, L_idx=[0, 1], affinity='precomputed'):\n",
        "  \n",
        "    pos = nx.get_node_attributes(G, 'pos')  # Extract node positions\n",
        "    \n",
        "    true_labels = list(nx.get_node_attributes(G, 'community').values())\n",
        "    true_colors = ['red' if label == true_labels[0] else 'blue' for label in true_labels]\n",
        "\n",
        "    col_slice = slice(1, samples.shape[1] + 1)\n",
        "\n",
        "    SC = SpectralClustering(n_clusters=n_clusters, affinity=affinity)\n",
        "    \n",
        "      \n",
        "    pred_colors_original, similarity_original = get_predColors_similarity(\n",
        "      samples,\n",
        "      col_slice,\n",
        "      n_neighbors,\n",
        "      true_labels\n",
        "    )\n",
        "    \n",
        "    pred_colors_mb, similarity_mb = get_predColors_similarity(\n",
        "      samples=None,\n",
        "      col_slice=None,\n",
        "      n_neighbors=None,\n",
        "      true_labels=true_labels,\n",
        "      b_original=False,\n",
        "      MB=MB\n",
        "    )\n",
        "\n",
        "\n",
        "\n",
        "    nx.draw(G, pos, node_color=true_colors, node_size=5, ax=axs[L_idx[0], 0], edge_color='lightgray')\n",
        "    nx.draw(MB, pos, node_color=true_colors, node_size=5, ax=axs[L_idx[0], 1], edge_color='lightgray')\n",
        "    \n",
        "    nx.draw(G, pos, node_color=pred_colors_original, node_size=5, ax=axs[L_idx[1], 0], edge_color='lightgray')\n",
        "    nx.draw(MB, pos, node_color=pred_colors_mb, node_size=5, ax=axs[L_idx[1], 1], edge_color='lightgray')\n",
        "    \n",
        "    return similarity_original, similarity_mb"
      ],
      "id": "def_get_predColors_similarity_def_draw",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/cloud/python/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}