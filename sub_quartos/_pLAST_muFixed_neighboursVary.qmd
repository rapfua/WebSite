# 8

##  {.sidebar width="300px"}

```{python}
#| label: input_selects_5
#| cache: True


input_select_width = 10

L = list(range(100, 501, 100))
L.insert(0, 50)

ui.input_select('n_simulations4', 'Number of simulations:',
                choices=[1, 3] + list(range(10, 101, 10)),
                selected=3,
                width=input_select_width
)

ui.input_select("n4", "Number of nodes in each cluster:",
                choices=L,
                selected=100,
                width=input_select_width
)

ui.input_select("d4", "Number of dimensions & communities:",
                choices=list((2, 3, 4)),
                selected=2,
                width=input_select_width
)


ui.input_select("mu_x24", "Mean of the second Gaussian with respect to the x-axis:",
                choices=list(range(1, 21)),
                selected=3,
                width=input_select_width
)





ui.input_select("R_14", "Big radius for intra-community edges:",
                choices=[round(i * 0.01, 2) for i in range(1, 201)],
                selected= 1,
                width=input_select_width
)

ui.input_select("R_24", "Small radius for inter-community edges:",
                choices=[round(i * 0.01, 2) for i in range(1, 101)],
                selected=0.5,
                width=input_select_width
)



```

## Column


```{python}
#| label: shiny_mu_fixed_n_neighbors_varying_simulation_hybrid
#| cache: True
@render.plot
def graph_mu_fixed_n_neighbors_varying_PLOT_HYBRID():
  
    λ           = 1

    F = make_F(f(φ(float(input.R_14()))), f(φ(float(input.R_24()))))
    
  
    n_simulations = int(input.n_simulations4())
    
    n           = int(input.n4())
    d           = int(input.d4())
    n_clusters  = d
    mu_x2       = float(input.mu_x24())
    
    n_neighbors_LIST = list(range(3, 51))

    fig, axs = plt.subplots(2, 1, figsize=(6, 12))
    
    dim3_labels = [f'similarity_{i}' for i in range(n_simulations)]
    
    array_3d = StringIndexed3DArray(array=np.zeros((len(n_neighbors_LIST), 2, n_simulations)), dim1_labels=n_neighbors_LIST, dim2_labels=['ARI_original', 'ARI_MB'], dim3_labels=dim3_labels)
    
    for i in range(n_simulations):
        print()
        print('Simulation:', i + 1, 'out of', n_simulations, 'started')
        print()
        
        samples = produce_samples(n, d, type_samples="gaussian", mu_x2=mu_x2, SEED=i)
        col_slice = slice(1, samples.shape[1] + 1)
        
        
        
        for j, n_neighbors in enumerate(n_neighbors_LIST):
            # Update G_distance separately
            G = produce_distance_graph(samples, n, d, framework='hybrid', F=F)
        
            W = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)
        
            edges = list(G.edges())
            weights = {(u, v): 1 / W[u, v] - 1 if W[u, v] > 0 else float('inf') for u, v in edges}
            nx.set_edge_attributes(G, weights, 'weight')
            
            MB = get_metric_backbone_igraph(G)
            
            
            true_labels = list(nx.get_node_attributes(G, 'community').values())
            true_colors = ['red' if label == true_labels[0] else 'blue' for label in true_labels]

            SC = SpectralClustering(n_clusters=n_clusters, affinity='precomputed')

            A = get_Gaussian_weight_matrix(samples[:, col_slice], n_neighbors)

            pred_labels = SC.fit_predict(A)
            pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]
            
            array_3d[n_neighbors, 'ARI_original', f'similarity_{i}'] = adjusted_rand_score(true_labels, pred_labels)
            
            
            A = nx.adjacency_matrix(MB, nodelist=[i for i in range(MB.number_of_nodes())], weight='proximity')
            A = scipy.sparse.csr_matrix(A)

            pred_labels = SC.fit_predict(A)
            pred_colors = ['red' if label == pred_labels[0] else 'blue' for label in pred_labels]
            
            array_3d[n_neighbors, 'ARI_MB', f'similarity_{i}'] = adjusted_rand_score(true_labels, pred_labels)
            
    
    
    axs[0].set_ylim(bottom=0, top=1)
    axs[0].plot(n_neighbors_LIST, array_3d.AVG_ARI_LIST(n_neighbors_LIST, 'ARI_original'))
    axs[0].errorbar(n_neighbors_LIST,  array_3d.AVG_ARI_LIST( n_neighbors_LIST, 'ARI_original'), yerr= array_3d.STD_ARI_LIST( n_neighbors_LIST, 'ARI_original'), fmt='o', label="Mean with Std Dev", alpha=0.5)
    axs[0].set_title('Original Graph')
    
    print(array_3d.STD_ARI_LIST(n_neighbors_LIST, 'ARI_MB'))
    print(array_3d)
    
    axs[1].set_ylim(0, 1)
    axs[1].plot(n_neighbors_LIST, array_3d.AVG_ARI_LIST(n_neighbors_LIST, 'ARI_MB'))
    axs[1].errorbar(n_neighbors_LIST,  array_3d.AVG_ARI_LIST( n_neighbors_LIST, 'ARI_MB'), yerr= array_3d.STD_ARI_LIST( n_neighbors_LIST, 'ARI_MB'), fmt='o', label="Mean with Std Dev", alpha=0.5)
    axs[1].set_title('Metric Backbone')
    
    for i in range(2):
        ax = axs[i]
        ax.set_xlabel('Number of nearest neighbors')
        ax.set_ylabel('ARI')
        ax.axis('on')
        ax.tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)
        if i < 2:
            ax.legend(handles=[produce_patch(color='red', framework='gaussian', mu_x2=0), produce_patch(color='blue', framework='gaussian', mu_x2=mu_x2)])
        else:
            ax.legend(handles=[produce_patch(color='red', framework='ABBE',  plus_or_minus_one=1), produce_patch(color='blue', framework='ABBE', plus_or_minus_one=-1)])
    

``` 